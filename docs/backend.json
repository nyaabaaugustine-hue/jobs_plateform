{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the ReactHire platform.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity."
        },
        "email": {
          "type": "string",
          "description": "User's email address.",
          "format": "email"
        },
        "firstName": {
          "type": "string",
          "description": "User's first name."
        },
        "lastName": {
          "type": "string",
          "description": "User's last name."
        },
        "role": {
          "type": "string",
          "description": "The role of the user in the system (e.g., jobSeeker, employer, admin)."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp indicating when the user account was created.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "Timestamp indicating when the user account was last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "email",
        "firstName",
        "lastName",
        "role",
        "createdAt",
        "updatedAt"
      ]
    },
    "Admin": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Admin",
      "type": "object",
      "description": "Represents an administrator account for managing the platform.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Admin entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: Admin 1:1 User)"
        },
        "permissions": {
          "type": "array",
          "description": "List of permissions granted to the administrator.",
          "items": {
            "type": "string"
          }
        },
        "lastLogin": {
          "type": "string",
          "description": "Timestamp of the admin's last login.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "permissions"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profiles. Uses path-based ownership for data access. The `userId` parameter corresponds to the Firebase Auth UID.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user, matching the Firebase Auth UID."
            }
          ]
        }
      },
      {
        "path": "/roles_admin/{userId}",
        "definition": {
          "entityName": "Admin",
          "schema": {
            "$ref": "#/backend/entities/Admin"
          },
          "description": "Determines admin status. The existence of a document in this collection grants admin privileges to the corresponding user. This existence is checked in the Firestore rules, rather than retrieving and validating the content of the `Admin` document.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user, matching the Firebase Auth UID. If a document exists for a given `userId`, that user is an admin."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to provide a secure, scalable, and debuggable solution for the ReactHire application, adhering to the principles of Authorization Independence, Clarity of Intent, DBAC, and QAPs. Authorization Independence is achieved through denormalization, where relevant authorization data (e.g., admin status) is copied into documents requiring access control. Structural Segregation is applied by separating user data and admin roles into distinct collections with homogeneous security postures. Access Modeling relies on path-based ownership for user-related data and existence checks for global admin roles. The structure is designed to ensure data clarity and predictability, using explicit state modeling and consistent naming conventions.\n\nSpecifically, the `users` collection stores user profiles. The `roles_admin` collection determines admin status based on document existence.  This design supports QAPs by enabling secure list operations. Admin status is determined by the existence of a document in `/roles_admin/{userId}`, enabling secure listing of all users.\n\nThis structure avoids hierarchical authorization dependencies (`get()` calls in rules), ensuring atomic operations and simplifying debugging. All authorization relies solely on `request.auth.uid` and database existence checks."
  }
}